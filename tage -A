[1mdiff --git a/learning_dist_metrics b/learning_dist_metrics[m
[1m--- a/learning_dist_metrics[m
[1m+++ b/learning_dist_metrics[m
[36m@@ -1 +1 @@[m
[31m-Subproject commit 0e4858b5c55237009faabf4442248b367e634404[m
[32m+[m[32mSubproject commit 0e4858b5c55237009faabf4442248b367e634404-dirty[m
[1mdiff --git a/learning_wrapper_dev.py b/learning_wrapper_dev.py[m
[1mindex 6243e08..f5812bf 100644[m
[1m--- a/learning_wrapper_dev.py[m
[1m+++ b/learning_wrapper_dev.py[m
[36m@@ -132,7 +132,7 @@[m [mis_plot = False[m
 image_name_prefix = "hist_id_"[m
 out_image_dir = IMG_PATH[m
 [m
[31m-def user_grouped_dist(user_id, weights, profile_df, friends_df):[m
[32m+[m[32mdef user_grouped_dist(user_id, weights, profile_df, friends_networkx):[m
     """ Calculate distances between a user and whose friends[m
         and distance between a user and whose non-friends.[m
         The groupped distance vector will be output.[m
[36m@@ -144,9 +144,8 @@[m [mdef user_grouped_dist(user_id, weights, profile_df, friends_df):[m
             is extracted by LDM().fit(x, y).get_transform_matrix()[m
         * profile_df: {matrix-like, pandas.DataFrame}, user profile dataframe[m
             with columns: ["ID", "x0" - "xn"][m
[31m-        * friends_df: {matrix-like, pandas.DataFrame}, pandas.DataFrame store[m
[31m-            pair of user ID(s) to represent connections with columns:[m
[31m-            ["uid_a", "uid_b"][m
[32m+[m[32m        * friends_networkx: {networkx.Graph()}, Graph() object from Networkx[m
[32m+[m[32m            to store the relationships information[m
 [m
         Returns:[m
         -------[m
[36m@@ -166,17 +165,15 @@[m [mdef user_grouped_dist(user_id, weights, profile_df, friends_df):[m
     # get the user profile information of the target users[m
     user_profile = profile_df.ix[profile_df.ID == user_id, cols].as_matrix()[m
     # get the user_id of friends of the target user[m
[31m-    friends_ls_a = friends_df[friends_df.uid_a == user_id].uid_b.as_matrix()[m
[31m-    friends_ls_b = friends_df[friends_df.uid_b == user_id].uid_a.as_matrix()[m
[31m-    friends_ls = list(set(friends_ls_a)) + list(set(friends_ls_b))[m
[31m-    # calculate the weighted distance of friends[m
[32m+[m[32m    friends_ls = friends_networkx.neighbors(user_id)[m
[32m+[m[32m    non_friends_ls = [u for u in profile_df.ID if u not in friends_ls + [user_id]][m
[32m+[m
     sim_dist_vec = [][m
     for f_id in friends_ls:[m
         friend_profile = profile_df.ix[profile_df.ID == f_id, cols].as_matrix()[m
         the_dist = weighted_euclidean(user_profile, friend_profile, weights)[m
         sim_dist_vec.append(the_dist)[m
[31m-    # calculate the weighted distances of non-friends[m
[31m-    non_friends_ls = [u for u in profile_df.ID if u not in friends_ls + [user_id]][m
[32m+[m
     diff_dist_vec = [][m
     for nf_id in non_friends_ls:[m
         nonfriend_profile = profile_df.ix[profile_df.ID == nf_id, cols].as_matrix()[m
[36m@@ -188,7 +185,7 @@[m [mdef user_grouped_dist(user_id, weights, profile_df, friends_df):[m
 [m
 [m
 def user_dist_kstest(sim_dist_vec, diff_dist_vec,[m
[31m-                     fit_rayleigh=True, min_nobs=10, _n=100):[m
[32m+[m[32m                     fit_rayleigh=False, min_nobs=10, _n=100):[m
     """ Test the goodness of a given weights to defferentiate friend distance[m
         distributions and non-friend distance distributions of a given user.[m
         The distance distribution is considered to follow Rayleigh distribution.[m
[36m@@ -287,10 +284,7 @@[m [mdef users_filter_by_weights(weights, users_list, profile_df, friends_df,[m
     for uid in users_list:[m
         res_dists = user_grouped_dist(uid, weights, profile_df, friends_df)[m
         pvals.append(user_dist_kstest(res_dists[0], res_dists[1]))[m
[31m-    #    if pval <= pval_threshold:[m
[31m-    #        good_fits.append(uid)[m
[31m-    #    else:[m
[31m-    #        bad_fits.append(uid)[m
[32m+[m
     sorted_id_pval = sorted(zip(users_list, pvals), key=lambda x: x[1])[m
     good_fits = [i for i, p in sorted_id_pval if p <= pval_threshold][m
     bad_fits = [i for i, p in sorted_id_pval if p > pval_threshold][m
